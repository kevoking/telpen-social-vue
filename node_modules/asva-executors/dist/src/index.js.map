{"version":3,"sources":["webpack://asva-executors/webpack/universalModuleDefinition","webpack://asva-executors/external \"tslib\"","webpack://asva-executors/webpack/bootstrap","webpack://asva-executors/webpack/runtime/define property getters","webpack://asva-executors/webpack/runtime/hasOwnProperty shorthand","webpack://asva-executors/webpack/runtime/make namespace object","webpack://asva-executors/./src/modules/Executors/Executor.ts","webpack://asva-executors/./src/modules/Executors/CacheExecutor.ts","webpack://asva-executors/./src/modules/Executors/LadderExecutor.ts","webpack://asva-executors/./src/modules/Loaders/DebounceLoader.ts","webpack://asva-executors/./src/modules/Loaders/RepeatLoader.ts","webpack://asva-executors/./src/modules/Loaders/InfiniteLoader.ts","webpack://asva-executors/./src/modules/Helpers/AsyncHelpers.ts","webpack://asva-executors/./src/modules/Loaders/RetrierExecutor.ts","webpack://asva-executors/./src/modules/Loaders/PointerRequestFactory.ts","webpack://asva-executors/./src/modules/Loaders/InfiniteLoaderFactory.ts","webpack://asva-executors/./src/modules/Executors/StatefulExecutor.ts"],"names":["root","factory","exports","module","require","define","amd","a","i","Function","__WEBPACK_EXTERNAL_MODULE__780__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","command","runCount","wasLastRunFine","wasRun","wasRunFine","wasRunBad","this","createAndRun","executor","Executor","run","beforeRun","promise","parameters","afterRun","then","setRunResultFlags","catch","success","cachedPromise","runFresh","cleanCache","trigger","isRunning","Promise","resolve","timeout","identityCheck","isWaiting","identityKey","registerIdentity","setTimeout","checkIdentity","reset","time","id","start","setInterval","stop","clearInterval","perStep","items","isFinished","isRefreshing","pointer","isFresh","refresh","runRequest","length","next","pointerRequest","result","Array","isArray","applyNew","console","warn","sleep","ms","maxTime","iterationCount","waitUntil","RetrierExecutor","takesTooLong","timeElapsed","Error","getPointerRequest","fill","map","item","index","createNumberedList","state","StatefulExecutor"],"mappings":"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","file":"src/index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"tslib\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"tslib\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"tslib\")) : factory(root[\"tslib\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(Function(\"return this\")(), function(__WEBPACK_EXTERNAL_MODULE__780__) {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__780__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export type ExecutorCommand = (...args: any[]) => Promise<any>\r\n\r\nexport default class Executor {\r\n  protected readonly command: ExecutorCommand\r\n\r\n  /**\r\n   * Currently running commands\r\n   */\r\n  public runCount: number = 0 //\r\n\r\n  /**\r\n   * Last executor run happened without an error\r\n   */\r\n  public wasLastRunFine: boolean = false //\r\n\r\n  /**\r\n   * Executor was run at least once\r\n   */\r\n  public wasRun: boolean = false\r\n\r\n  /**\r\n   * Executor was run without throwing error at least once\r\n   */\r\n  public wasRunFine: boolean = false\r\n\r\n  /**\r\n   * Executor was run with thrown error at least once\r\n   */\r\n  public wasRunBad: boolean = false\r\n\r\n  constructor (command: ExecutorCommand) {\r\n    this.command = command\r\n  }\r\n\r\n  static createAndRun (command: ExecutorCommand): Executor {\r\n    const executor = new Executor(command)\r\n    executor.run()\r\n    return executor\r\n  }\r\n\r\n  /**\r\n   * Command from this executor is currently running.\r\n   */\r\n  public get isRunning (): boolean {\r\n    return !!this.runCount\r\n  }\r\n\r\n  /**\r\n   * @param parameters Arguments, will be passed down to command.\r\n   * @returns {Promise<any>} Promise result is formed from whatever you returned from command.\r\n   */\r\n  public run (...parameters: any[]): Promise<any> {\r\n    this.beforeRun()\r\n    const promise = this.command(...parameters)\r\n    // NOTE This check was broken on second package import (package one < package two < executor)\r\n    // if (!(promise instanceof Promise)) {\r\n    //   throw new Error('Executor command should return promise.')\r\n    // }\r\n    this.afterRun(promise)\r\n    return promise\r\n  }\r\n\r\n  protected beforeRun (): void {\r\n    this.runCount++\r\n  }\r\n\r\n  protected afterRun (promise: Promise<any>): void {\r\n    promise.then(() => {\r\n      this.runCount--\r\n      this.setRunResultFlags(true)\r\n    })\r\n    promise.catch(() => {\r\n      this.runCount--\r\n      this.setRunResultFlags(false)\r\n    })\r\n  }\r\n\r\n  protected setRunResultFlags (success: boolean): void {\r\n    this.wasRun = true\r\n    this.wasLastRunFine = success\r\n    if (success) {\r\n      this.wasRunFine = true\r\n    }\r\n    if (!success) {\r\n      this.wasRunBad = true\r\n    }\r\n  }\r\n}\r\n","import Executor from './Executor'\r\n\r\n/**\r\n * This executor caches first run result and provides it for all subsequent calls.\r\n */\r\nexport default class CacheExecutor extends Executor {\r\n  protected cachedPromise: Promise<any> | null = null\r\n\r\n  /**\r\n   * Run command and cache promise.\r\n   */\r\n  public run (...parameters: any[]): Promise<any> {\r\n    if (!this.cachedPromise) {\r\n      this.cachedPromise = super.run(...parameters)\r\n    }\r\n    return this.cachedPromise\r\n  }\r\n\r\n  /**\r\n   * Run executor without cache. Promise will be put to cache though.\r\n   */\r\n  public runFresh (...parameters: any[]): Promise<any> {\r\n    this.cachedPromise = super.run(...parameters)\r\n    return this.cachedPromise\r\n  }\r\n\r\n  /**\r\n   * Just clean cache.\r\n   */\r\n  public cleanCache () {\r\n    this.cachedPromise = null\r\n  }\r\n}","import Executor from './Executor'\r\n\r\n/**\r\n * This executor will chain requests ladder-like.\r\n * Last one will always be executed.\r\n * For skipped requests the promise will never be resolved.\r\n */\r\nexport default class LadderExecutor extends Executor {\r\n  private trigger: Function | null = null\r\n\r\n  public run (...parameters: any[]): Promise<any>  {\r\n    if (!this.isRunning) {\r\n      const promise = super.run(...parameters)\r\n      promise.then(() => {\r\n        this.trigger && this.trigger()\r\n        this.trigger = null\r\n      })\r\n      return promise\r\n    }\r\n\r\n    return new Promise((resolve) => {\r\n      this.trigger = () => this.run(...parameters).then(resolve)\r\n    })\r\n  }\r\n}\r\n","import Executor, { ExecutorCommand } from '../Executors/Executor'\r\n\r\n/**\r\n * When you `run` executor - timer is set on timeout value and starts ticking down.\r\n * If you `run` before the timer is expired - timer is refreshed.\r\n * When timer expires - command is being run.\r\n */\r\nexport default class DebounceLoader {\r\n  protected executor: Executor\r\n  protected timeout: number\r\n\r\n  protected identityCheck: {} = {}\r\n  public isWaiting: boolean = false\r\n\r\n  constructor (command: ExecutorCommand, timeout: number = 3000) {\r\n    this.executor = new Executor(command)\r\n    this.timeout = timeout\r\n  }\r\n\r\n  public get isRunning (): boolean {\r\n    return this.executor.isRunning\r\n  }\r\n\r\n  public get isActive (): boolean {\r\n    return this.isRunning || this.isWaiting\r\n  }\r\n\r\n  public run (...parameters: any[]): void {\r\n    this.isWaiting = true\r\n    const identityKey = this.registerIdentity()\r\n\r\n    setTimeout(() => {\r\n      if (! this.checkIdentity(identityKey)) {\r\n        return\r\n      }\r\n\r\n      this.isWaiting = false\r\n      this.executor.run(...parameters)\r\n    }, this.timeout)\r\n  }\r\n\r\n  public reset (): void {\r\n    this.isWaiting = false\r\n    this.identityCheck = {}\r\n  }\r\n\r\n  protected registerIdentity (): {} {\r\n    this.identityCheck = {}\r\n    return this.identityCheck\r\n  }\r\n\r\n  protected checkIdentity (key: {}): boolean {\r\n    return this.identityCheck === key\r\n  }\r\n}\r\n","/**\r\n * Runs command on timeout.\r\n * Don't forget to stop it or executor would run indefinitely.\r\n */\r\nexport default class RepeatLoader {\r\n  command: Function\r\n  time: number = 100\r\n  id: any = null\r\n\r\n  constructor (command: Function, time: number) {\r\n    this.command = command\r\n    this.time = time\r\n  }\r\n\r\n  public start (): void {\r\n    if (!this.id) {\r\n      this.id = setInterval(this.command, this.time)\r\n    }\r\n  }\r\n\r\n  public stop (): void {\r\n    if (this.id) {\r\n      clearInterval(this.id)\r\n    }\r\n    this.id = null\r\n  }\r\n}","import LadderExecutor from '../Executors/LadderExecutor'\r\n\r\nexport type PointerRequest = (pointer: number, perStep: number) => Promise<any[]>\r\n\r\nexport default class InfiniteLoader {\r\n  public items: any[] = []\r\n  public isFinished: boolean = false\r\n  public isRefreshing: boolean = false\r\n\r\n  protected readonly executor: LadderExecutor\r\n  protected readonly perStep: number = 20 // number of items to load\r\n  protected pointer: number = 0\r\n  // Means no runs were executed\r\n  protected isFresh: boolean = true\r\n  // Is currently running from 0 pointer\r\n\r\n  constructor (run: PointerRequest, perStep: number = 20) {\r\n    this.executor = new LadderExecutor(async (refresh = false) => await this.runRequest(run, refresh))\r\n    this.perStep = perStep\r\n  }\r\n\r\n  /**\r\n   * Command from this executor is currently running.\r\n   */\r\n  get isRunning (): boolean {\r\n    return this.executor.isRunning\r\n  }\r\n\r\n  /**\r\n   * We tried to load, but list is empty\r\n   * Is false when executor is loading or is fresh.\r\n   */\r\n  get isEmpty (): boolean {\r\n    if (this.executor.isRunning) {\r\n      return false\r\n    }\r\n    return this.isFinished && (this.items.length === 0)\r\n  }\r\n\r\n  /**\r\n   * We tried to load, and list is not empty\r\n   * Is false when executor is loading or is fresh.\r\n   */\r\n  get isFull (): boolean {\r\n    if (this.isFresh) {\r\n      return false\r\n    }\r\n    if (this.executor.isRunning) {\r\n      return false\r\n    }\r\n    return !!this.items.length\r\n  }\r\n\r\n  /**\r\n   * Loads a bunch of items\r\n   */\r\n  public next (): void {\r\n    this.executor.run()\r\n  }\r\n\r\n  /**\r\n   * Refresh the list.\r\n   */\r\n  public refresh (): void {\r\n    this.executor.run(true)\r\n  }\r\n\r\n  protected async runRequest (pointerRequest: PointerRequest, refresh = false): Promise<void> {\r\n    if (this.pointer === 0) {\r\n      refresh = true\r\n    }\r\n    if (refresh) {\r\n      this.pointer = 0\r\n      this.isFresh = true\r\n      this.isRefreshing = true\r\n      this.isFinished = false\r\n    }\r\n    try {\r\n      const result = await pointerRequest(this.pointer, this.perStep)\r\n\r\n      if (!Array.isArray(result)) {\r\n        console.warn('InfiniteLoader function must return array')\r\n        return\r\n      }\r\n      if (result.length < this.perStep) {\r\n        this.isFinished = true\r\n      }\r\n\r\n      this.applyNew(result)\r\n      this.pointer = this.pointer + this.perStep\r\n      this.isFresh = false\r\n    } catch (exception) {\r\n      this.isFinished = true\r\n      throw exception\r\n    } finally {\r\n      this.isRefreshing = false\r\n    }\r\n  }\r\n\r\n  protected applyNew (items: any[]): void {\r\n    if (this.isFresh) {\r\n      this.items = items\r\n      return\r\n    }\r\n    this.items = [...this.items, ...items]\r\n  }\r\n}\r\n","export default class AsyncHelpers {\r\n  static sleep(ms: number): Promise<void> {\r\n    return new Promise(resolve => setTimeout(resolve, ms))\r\n  }\r\n}","import AsyncHelpers from '../Helpers/AsyncHelpers'\r\n\r\nexport type RetrierExecutorCommand = () => boolean\r\n\r\nexport default class RetrierExecutor {\r\n  protected command: RetrierExecutorCommand\r\n  protected timeout: number\r\n  protected maxTime: number\r\n  public iterationCount: number = 0\r\n\r\n  constructor (command: RetrierExecutorCommand, timeout: number = 100, maxTime: number = 1000) {\r\n    this.command = command\r\n    this.timeout = timeout\r\n    this.maxTime = maxTime\r\n  }\r\n\r\n  /**\r\n   * Shortcut to use executor functionally.\r\n   */\r\n  static async waitUntil (command: RetrierExecutorCommand, timeout?: number, maxTime?: number) {\r\n    const executor = new RetrierExecutor(command, timeout, maxTime)\r\n    await executor.run()\r\n  }\r\n\r\n  get timeElapsed () {\r\n    return this.timeout * this.iterationCount\r\n  }\r\n\r\n  protected takesTooLong (): boolean {\r\n    return this.timeElapsed > this.maxTime\r\n  }\r\n\r\n  async run (): Promise<void> {\r\n    this.iterationCount = 0\r\n    let result = this.command()\r\n    while (!result) {\r\n      await AsyncHelpers.sleep(this.timeout)\r\n      this.iterationCount++\r\n      if (this.takesTooLong()) {\r\n        throw new Error(`Max time (${this.maxTime}) elapsed.`)\r\n      }\r\n\r\n      result = this.command()\r\n    }\r\n  }\r\n}\r\n","import { PointerRequest } from './InfiniteLoader'\r\n\r\n/**\r\n * Generate an array with sequence of numbers\r\n */\r\nfunction range (start: number, end: number): number[] {\r\n  const length = (end - start)\r\n  return Array(length).fill(0).map((item, index: number) => start + index)\r\n}\r\n\r\nexport default class PointerRequestFactory {\r\n  static getPointerRequest (timeout: number = 100): PointerRequest {\r\n    return (pointer: number, perStep: number): Promise<number[]> => {\r\n      return new Promise((resolve) => {\r\n        setTimeout(() => {\r\n          resolve(range(pointer, pointer + perStep))\r\n        }, timeout)\r\n      })\r\n    }\r\n  }\r\n}","import PointerRequestFactory from './PointerRequestFactory'\r\nimport InfiniteLoader from './InfiniteLoader'\r\n\r\nexport class InfiniteLoaderFactory {\r\n  /**\r\n   * Infinite loader generating a list of numbers by tens\r\n   */\r\n  static createNumberedList (timeout: number = 300): InfiniteLoader {\r\n    const pointerRequest = PointerRequestFactory.getPointerRequest(timeout)\r\n    return new InfiniteLoader(pointerRequest, 10)\r\n  }\r\n}","import Executor, { ExecutorCommand } from './Executor'\r\n\r\n/**\r\n * This executor keeps state of last result\r\n */\r\nexport class StatefulExecutor extends Executor {\r\n  public state: any\r\n\r\n  public constructor (command: ExecutorCommand, state: any = null) {\r\n    super(command)\r\n    this.state = state\r\n  }\r\n\r\n  static createAndRun (command: ExecutorCommand, state: any = null): StatefulExecutor {\r\n    const executor = new StatefulExecutor(command, state)\r\n    executor.run()\r\n    return executor\r\n  }\r\n\r\n  /**\r\n   * Run command and cache promise.\r\n   */\r\n  public run (...parameters: any[]): Promise<any> {\r\n    const promise = super.run(...parameters)\r\n    promise.then(result => {\r\n      this.state = result\r\n    })\r\n    return promise\r\n  }\r\n}\r\n"],"sourceRoot":""}