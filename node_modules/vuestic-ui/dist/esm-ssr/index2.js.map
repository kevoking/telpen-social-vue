{"version":3,"file":"index2.js","sources":["../../src/components/va-affix/VaAffix-utils.ts","../../src/components/va-affix/VaAffix.vue","../../src/components/va-affix/VaAffix.vue?vue&type=template&id=c9e05218&lang.js","../../src/components/va-affix/index.ts"],"sourcesContent":["import { throttle } from 'lodash-es'\r\nimport { Vue } from 'vue-class-component'\r\n\r\nexport type State = {\r\n  isTopAffixed: boolean;\r\n  isBottomAffixed: boolean;\r\n  width?: number;\r\n}\r\n\r\ntype Coordinates = {\r\n  top: number;\r\n  bottom: number;\r\n}\r\n\r\ntype ValuesToComputeAffixedState = {\r\n  coordinates: Coordinates;\r\n  offsetTop?: number;\r\n  offsetBottom?: number;\r\n  target: HTMLElement | Window | undefined;\r\n}\r\n\r\nexport function getWindowHeight () {\r\n  return document.documentElement.clientHeight ||\r\n    window.innerHeight ||\r\n    document.body.clientHeight\r\n}\r\n\r\nexport function computeAffixedState ({\r\n  coordinates,\r\n  offsetTop,\r\n  offsetBottom,\r\n  target,\r\n}: ValuesToComputeAffixedState): State {\r\n  let isTopAffixed = false\r\n  let isBottomAffixed = false\r\n\r\n  const windowHeight = getWindowHeight()\r\n\r\n  if (offsetTop != null && windowHeight) {\r\n    if (target === window) {\r\n      isTopAffixed = coordinates.top <= offsetTop\r\n    } else {\r\n      const { top } = (target as HTMLElement).getBoundingClientRect()\r\n      isTopAffixed = coordinates.top - top <= offsetTop\r\n    }\r\n  }\r\n\r\n  if (offsetBottom != null && windowHeight) {\r\n    if (target === window) {\r\n      isBottomAffixed = coordinates.bottom >= windowHeight - offsetBottom\r\n    } else {\r\n      const { bottom } = (target as HTMLElement).getBoundingClientRect()\r\n      isBottomAffixed = bottom - coordinates.bottom <= offsetBottom\r\n    }\r\n  }\r\n\r\n  return {\r\n    isTopAffixed,\r\n    isBottomAffixed,\r\n  }\r\n}\r\n\r\nfunction checkAffixedStateChange (currentState: State, nextState: State): boolean {\r\n  return currentState.isTopAffixed !== nextState.isTopAffixed ||\r\n    currentState.isBottomAffixed !== nextState.isBottomAffixed\r\n}\r\n\r\nexport type Context = {\r\n  offsetTop?: number;\r\n  offsetBottom?: number;\r\n  element: Vue | Element | Vue[] | Element[];\r\n  target: HTMLElement | Window | undefined;\r\n  setState: (state: State) => void;\r\n  getState: () => State;\r\n  initialPosition?: ClientRect;\r\n}\r\n\r\nexport function handleThrottledEvent (eventName: string | null, context: Context) {\r\n  const { target, element, offsetTop, offsetBottom, setState, getState, initialPosition } = context\r\n\r\n  let nextState\r\n\r\n  const isInitialCall = !eventName\r\n\r\n  // Fixme: getBoundingClientRect should always exist on element\r\n  const coordinates = (element as HTMLElement).getBoundingClientRect()\r\n\r\n  const options = {\r\n    offsetBottom,\r\n    offsetTop,\r\n    target,\r\n  }\r\n\r\n  if (isInitialCall && initialPosition) {\r\n    nextState = computeAffixedState({ coordinates: initialPosition, ...options })\r\n  } else {\r\n    nextState = computeAffixedState({ coordinates, ...options })\r\n  }\r\n\r\n  const prevState = getState()\r\n\r\n  if (checkAffixedStateChange(prevState, nextState)) {\r\n    setState({ ...nextState, width: coordinates.width })\r\n  } else if (prevState.width !== coordinates.width) {\r\n    setState({ ...prevState, width: coordinates.width })\r\n  }\r\n}\r\n\r\nfunction useCaptureDefault (eventName: string) {\r\n  // This event type must bubble to the Window object only when dispatched on the Document element\r\n  // https://www.w3.org/TR/2014/WD-DOM-Level-3-Events-20140925/#event-type-scroll\r\n  return eventName === 'scroll'\r\n}\r\n\r\ntype Options = {\r\n  handler: (eventName: string, event: Event) => void;\r\n  useCapture?: (eventName: string) => boolean;\r\n  wait?: number;\r\n}\r\n\r\nexport function useEventsHandlerWithThrottle (events: string[], {\r\n  handler,\r\n  useCapture = useCaptureDefault,\r\n  wait = 50,\r\n}: Options) {\r\n  const clearHandlersArray = events.map(eventName => {\r\n    const _handler = throttle((event: Event) => handler(eventName, event), wait)\r\n\r\n    window.addEventListener(eventName, _handler, useCapture(eventName))\r\n\r\n    return () => window.removeEventListener(eventName, _handler, useCapture(eventName))\r\n  })\r\n\r\n  return () => clearHandlersArray.forEach(clear => clear())\r\n}\r\n","<template>\r\n  <div\r\n    ref=\"element\"\r\n    class=\"va-affix\"\r\n  >\r\n    <div :style=\"{ visibility: isAffixed ? 'hidden' : 'inherit' }\">\r\n      <slot />\r\n    </div>\r\n    <div\r\n      v-if=\"isAffixed\"\r\n      :class=\"computedClass\"\r\n      :style=\"computedStyle\"\r\n    >\r\n      <slot />\r\n    </div>\r\n  </div>\r\n</template>\r\n<script lang=\"ts\">\r\nimport { noop } from 'lodash-es'\r\nimport { Options, prop, mixins, Vue } from 'vue-class-component'\r\n\r\nimport {\r\n  handleThrottledEvent,\r\n  useEventsHandlerWithThrottle,\r\n  getWindowHeight,\r\n  State, Context,\r\n} from './VaAffix-utils'\r\n\r\nclass AffixProps {\r\n  offsetTop = prop<number>({ type: Number, default: undefined })\r\n  offsetBottom = prop<number>({ type: Number, default: undefined })\r\n  target = prop({ type: Function, default: () => () => window })\r\n}\r\n\r\nconst AffixPropsMixin = Vue.with(AffixProps)\r\n\r\n@Options({\r\n  name: 'VaAffix',\r\n  emits: ['change'],\r\n})\r\nexport default class VaAffix extends mixins(\r\n  AffixPropsMixin,\r\n) {\r\n  private state: State = {\r\n    isTopAffixed: false,\r\n    isBottomAffixed: false,\r\n  }\r\n\r\n  private initialPosition?: undefined | DOMRect\r\n  private clearEventListeners = noop\r\n\r\n  get computedClass () {\r\n    return [\r\n      {\r\n        'va-affix--affixed': this.isAffixed,\r\n      },\r\n    ]\r\n  }\r\n\r\n  getTargetElement () {\r\n    // a custom target may get rendered later than\r\n    // a component gets a property from the context\r\n    const { target } = this\r\n    return target()\r\n  }\r\n\r\n  get computedStyle () {\r\n    const calculateTop = () => {\r\n      const target = this.getTargetElement()\r\n\r\n      if (this.offsetTop === undefined) {\r\n        return\r\n      }\r\n\r\n      if (target !== window) {\r\n        const { top } = (target as HTMLElement).getBoundingClientRect()\r\n        return top + this.offsetTop\r\n      }\r\n\r\n      return this.offsetTop\r\n    }\r\n\r\n    const calculateBottom = () => {\r\n      const target = this.getTargetElement()\r\n      if (this.offsetBottom === undefined) {\r\n        return\r\n      }\r\n\r\n      if (target !== window) {\r\n        const { bottom } = (target as HTMLElement).getBoundingClientRect()\r\n        const { offsetHeight, clientHeight } = (target as HTMLElement)\r\n        const scrollBarHeight = offsetHeight - clientHeight\r\n        const windowHeight = getWindowHeight()\r\n        return windowHeight - (bottom - this.offsetBottom) + scrollBarHeight\r\n      }\r\n\r\n      return this.offsetBottom\r\n    }\r\n\r\n    const convertToPixels = (calculate: () => number | undefined) => {\r\n      const result = calculate()\r\n\r\n      if (result === undefined) {\r\n        return\r\n      }\r\n\r\n      return `${result}px`\r\n    }\r\n\r\n    return {\r\n      top: this.state.isTopAffixed ? convertToPixels(calculateTop) : null,\r\n      bottom: this.state.isBottomAffixed ? convertToPixels(calculateBottom) : null,\r\n      width: `${this.state.width}px`,\r\n    }\r\n  }\r\n\r\n  get isAffixed (): boolean {\r\n    return this.state.isTopAffixed || this.state.isBottomAffixed\r\n  }\r\n\r\n  handleThrottledEvent (eventName: string | null, event?: Event) {\r\n    const context: Context = {\r\n      ...this.$data,\r\n      ...this.$props,\r\n      element: this.$refs.element as any,\r\n      target: this.getTargetElement(),\r\n      setState: this.setState.bind(this),\r\n      getState: this.getState.bind(this),\r\n    }\r\n\r\n    if (!eventName || eventName === 'resize') {\r\n      handleThrottledEvent(eventName, context)\r\n    } else if (event && event.target) {\r\n      const target = this.getTargetElement()\r\n\r\n      if ((target as HTMLElement) === event.target || target === window) {\r\n        handleThrottledEvent(eventName, context)\r\n      } else {\r\n        // if we have a custom target but keep scrolling on another element,\r\n        // so just disable the affixed state\r\n        this.setState({\r\n          isBottomAffixed: false,\r\n          isTopAffixed: false,\r\n        })\r\n      }\r\n    }\r\n  }\r\n\r\n  setState (state: State) {\r\n    this.state = state\r\n    this.$emit('change', this.isAffixed)\r\n  }\r\n\r\n  getState () {\r\n    return this.state\r\n  }\r\n\r\n  mounted () {\r\n    const events = ['scroll', 'resize']\r\n\r\n    this.initialPosition = (this.$refs.element as HTMLElement).getBoundingClientRect()\r\n\r\n    this.clearEventListeners = useEventsHandlerWithThrottle(events, {\r\n      handler: this.handleThrottledEvent,\r\n    })\r\n\r\n    this.$nextTick(() => {\r\n      // pass `null` here to make sure it is an initial call\r\n      this.handleThrottledEvent(null)\r\n    })\r\n  }\r\n\r\n  beforeUnmount () {\r\n    this.clearEventListeners()\r\n  }\r\n}\r\n</script>\r\n\r\n<style lang=\"scss\">\r\n@import '../../styles/resources/resources';\r\n@import 'variables';\r\n\r\n.va-affix {\r\n  &--affixed {\r\n    position: var(--va-affix-affixed-position);\r\n    z-index: var(--va-affix-affixed-zindex);\r\n  }\r\n}\r\n</style>\r\n","<template>\r\n  <div\r\n    ref=\"element\"\r\n    class=\"va-affix\"\r\n  >\r\n    <div :style=\"{ visibility: isAffixed ? 'hidden' : 'inherit' }\">\r\n      <slot />\r\n    </div>\r\n    <div\r\n      v-if=\"isAffixed\"\r\n      :class=\"computedClass\"\r\n      :style=\"computedStyle\"\r\n    >\r\n      <slot />\r\n    </div>\r\n  </div>\r\n</template>\r\n<script lang=\"ts\">\r\nimport { noop } from 'lodash-es'\r\nimport { Options, prop, mixins, Vue } from 'vue-class-component'\r\n\r\nimport {\r\n  handleThrottledEvent,\r\n  useEventsHandlerWithThrottle,\r\n  getWindowHeight,\r\n  State, Context,\r\n} from './VaAffix-utils'\r\n\r\nclass AffixProps {\r\n  offsetTop = prop<number>({ type: Number, default: undefined })\r\n  offsetBottom = prop<number>({ type: Number, default: undefined })\r\n  target = prop({ type: Function, default: () => () => window })\r\n}\r\n\r\nconst AffixPropsMixin = Vue.with(AffixProps)\r\n\r\n@Options({\r\n  name: 'VaAffix',\r\n  emits: ['change'],\r\n})\r\nexport default class VaAffix extends mixins(\r\n  AffixPropsMixin,\r\n) {\r\n  private state: State = {\r\n    isTopAffixed: false,\r\n    isBottomAffixed: false,\r\n  }\r\n\r\n  private initialPosition?: undefined | DOMRect\r\n  private clearEventListeners = noop\r\n\r\n  get computedClass () {\r\n    return [\r\n      {\r\n        'va-affix--affixed': this.isAffixed,\r\n      },\r\n    ]\r\n  }\r\n\r\n  getTargetElement () {\r\n    // a custom target may get rendered later than\r\n    // a component gets a property from the context\r\n    const { target } = this\r\n    return target()\r\n  }\r\n\r\n  get computedStyle () {\r\n    const calculateTop = () => {\r\n      const target = this.getTargetElement()\r\n\r\n      if (this.offsetTop === undefined) {\r\n        return\r\n      }\r\n\r\n      if (target !== window) {\r\n        const { top } = (target as HTMLElement).getBoundingClientRect()\r\n        return top + this.offsetTop\r\n      }\r\n\r\n      return this.offsetTop\r\n    }\r\n\r\n    const calculateBottom = () => {\r\n      const target = this.getTargetElement()\r\n      if (this.offsetBottom === undefined) {\r\n        return\r\n      }\r\n\r\n      if (target !== window) {\r\n        const { bottom } = (target as HTMLElement).getBoundingClientRect()\r\n        const { offsetHeight, clientHeight } = (target as HTMLElement)\r\n        const scrollBarHeight = offsetHeight - clientHeight\r\n        const windowHeight = getWindowHeight()\r\n        return windowHeight - (bottom - this.offsetBottom) + scrollBarHeight\r\n      }\r\n\r\n      return this.offsetBottom\r\n    }\r\n\r\n    const convertToPixels = (calculate: () => number | undefined) => {\r\n      const result = calculate()\r\n\r\n      if (result === undefined) {\r\n        return\r\n      }\r\n\r\n      return `${result}px`\r\n    }\r\n\r\n    return {\r\n      top: this.state.isTopAffixed ? convertToPixels(calculateTop) : null,\r\n      bottom: this.state.isBottomAffixed ? convertToPixels(calculateBottom) : null,\r\n      width: `${this.state.width}px`,\r\n    }\r\n  }\r\n\r\n  get isAffixed (): boolean {\r\n    return this.state.isTopAffixed || this.state.isBottomAffixed\r\n  }\r\n\r\n  handleThrottledEvent (eventName: string | null, event?: Event) {\r\n    const context: Context = {\r\n      ...this.$data,\r\n      ...this.$props,\r\n      element: this.$refs.element as any,\r\n      target: this.getTargetElement(),\r\n      setState: this.setState.bind(this),\r\n      getState: this.getState.bind(this),\r\n    }\r\n\r\n    if (!eventName || eventName === 'resize') {\r\n      handleThrottledEvent(eventName, context)\r\n    } else if (event && event.target) {\r\n      const target = this.getTargetElement()\r\n\r\n      if ((target as HTMLElement) === event.target || target === window) {\r\n        handleThrottledEvent(eventName, context)\r\n      } else {\r\n        // if we have a custom target but keep scrolling on another element,\r\n        // so just disable the affixed state\r\n        this.setState({\r\n          isBottomAffixed: false,\r\n          isTopAffixed: false,\r\n        })\r\n      }\r\n    }\r\n  }\r\n\r\n  setState (state: State) {\r\n    this.state = state\r\n    this.$emit('change', this.isAffixed)\r\n  }\r\n\r\n  getState () {\r\n    return this.state\r\n  }\r\n\r\n  mounted () {\r\n    const events = ['scroll', 'resize']\r\n\r\n    this.initialPosition = (this.$refs.element as HTMLElement).getBoundingClientRect()\r\n\r\n    this.clearEventListeners = useEventsHandlerWithThrottle(events, {\r\n      handler: this.handleThrottledEvent,\r\n    })\r\n\r\n    this.$nextTick(() => {\r\n      // pass `null` here to make sure it is an initial call\r\n      this.handleThrottledEvent(null)\r\n    })\r\n  }\r\n\r\n  beforeUnmount () {\r\n    this.clearEventListeners()\r\n  }\r\n}\r\n</script>\r\n\r\n<style lang=\"scss\">\r\n@import '../../styles/resources/resources';\r\n@import 'variables';\r\n\r\n.va-affix {\r\n  &--affixed {\r\n    position: var(--va-affix-affixed-position);\r\n    z-index: var(--va-affix-affixed-zindex);\r\n  }\r\n}\r\n</style>\r\n","import withConfigTransport from '../../services/config-transport/withConfigTransport'\r\nimport VaAffix from './VaAffix.vue'\r\n\r\nexport default withConfigTransport(VaAffix)\r\n"],"names":["getWindowHeight","document","documentElement","clientHeight","window","innerHeight","body","computeAffixedState","coordinates","offsetTop","offsetBottom","target","isTopAffixed","isBottomAffixed","windowHeight","top","getBoundingClientRect","bottom","handleThrottledEvent","eventName","context","element","setState","getState","initialPosition","nextState","isInitialCall","options","prevState","checkAffixedStateChange","currentState","width","useCaptureDefault","AffixPropsMixin","Vue","with","AffixProps","constructor","this","prop","type","Number","default","undefined","Function","VaAffix","mixins","noop","computedClass","isAffixed","getTargetElement","computedStyle","convertToPixels","calculate","result","state","offsetHeight","scrollBarHeight","event","$data","$props","$refs","bind","$emit","mounted","clearEventListeners","useEventsHandlerWithThrottle","events","handler","useCapture","wait","clearHandlersArray","map","_handler","throttle","addEventListener","removeEventListener","forEach","clear","$nextTick","beforeUnmount","Options","name","emits","_mergeProps","ref","class","_ctx","withConfigTransport"],"mappings":"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"}